import os
import time
import win32api, win32con
from PIL import ImageOps
from PIL import ImageGrab
from PIL import Image
from numpy import *
import cv2 as cv
import numpy as np
from matplotlib import pyplot as plt
x_pad = 3
y_pad = 25


def grab():
    box = (x_pad + 1,y_pad+1,x_pad+640,y_pad+480)
    im = ImageOps.grayscale(ImageGrab.grab(box))
    a = array(im.getcolors())
    a = a.sum()
    print (a)
    return a

def screenGrab():
    mousePos((x_pad + 390, y_pad + 223))
    leftClick()
    time.sleep(1)
    mousePos((x_pad + 174, y_pad + 141))
    leftClick()
    time.sleep(1)
    Directory = os.getcwd() + '\\Images'
    box = (x_pad,y_pad,x_pad + 640,y_pad + 480)
    im = ImageGrab.grab(box)
    im.save(Directory + '\\SnapShot\\full_snap__' + str(int(time.time())) +
            '.png', 'PNG')
    img_rgb = cv.imread(Directory + '\\SnapShot\\full_snap__' + str(int(time.time())) +
            '.png')


    # define the list of color boundaries
    boundaries = [
        ([155, 155, 150], [220, 210, 200])
    ]

    # loop over the boundaries
    for (lower, upper) in boundaries:
        # create NumPy arrays from the boundaries
        lower = np.array(lower, dtype="uint8")
        upper = np.array(upper, dtype="uint8")

        # find the colors within the specified boundaries
        mask = cv.inRange(img_rgb, lower, upper)



        # merge the mask into the accumulated masks
        output = cv.bitwise_and(img_rgb, img_rgb, mask=mask)

        im = np.asarray(Image.fromarray(output))

    im_grey = cv.cvtColor(im, cv.COLOR_BGR2GRAY)
    index = 0
    CornerXCoord = []
    CornerYCoord = []
    for filename in os.listdir(Directory + '\\Corners'):
        if filename.endswith(".PNG"):
            print(filename)
            template = cv.imread(Directory + '\\Corners\\' + filename, 0)
            w, h = template.shape[::-1]
            res = cv.matchTemplate(im_grey, template, cv.TM_CCOEFF_NORMED)
            threshold = 0.8
            loc = np.where(res >= threshold)
            CornerXCoord.append(loc[1][0])
            CornerYCoord.append(loc[0][0])
            for pt in zip(*loc[::-1]):
                cv.rectangle(im, pt, (pt[0] + w, pt[1] + h), (0, 0, 255), 2)
            cv.imwrite('rea.png', im)
        else:
            print("wrong extension")

    ObjectXCoord = []
    ObjectYCoord = []
    img_grey = cv.cvtColor(img_rgb, cv.COLOR_BGR2GRAY)
    for filename in os.listdir(Directory + '\\Objects'):
        if filename.endswith(".PNG"):
            print(filename)
            template = cv.imread(Directory + '\\Objects\\' + filename, 0)
            w, h = template.shape[::-1]
            res = cv.matchTemplate(img_grey, template, cv.TM_CCOEFF_NORMED)
            threshold = 0.8
            loc = np.where(res >= threshold)


            if list(zip(*loc)):
                print("loc",loc[1][0])
                print(loc)
                ObjectXCoord.append(loc[1][0])
                ObjectYCoord.append(loc[0][0])

            for pt in zip(*loc[::-1]):


                cv.rectangle(img_rgb, pt, (pt[0] + w, pt[1] + h), (0, 0, 255), 2)
            cv.imwrite('res.png', img_rgb)
        else:
            print("wrong extension")

    print((CornerXCoord[0] - CornerXCoord[1]) / 40)
    print((CornerYCoord[0]- CornerYCoord[1])/30)
    print(ObjectXCoord)
    print(ObjectYCoord)
    print(CornerXCoord[1])
    print(CornerYCoord[1])
    print((ObjectXCoord[0] - CornerXCoord[1]) / 40)
    print((ObjectYCoord[0] - CornerYCoord[1]) / 30)
    print((ObjectXCoord[1] - CornerXCoord[1]) / 40)
    print((ObjectYCoord[1] - CornerYCoord[1]) / 30)






def leftClick():
    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN,0,0)
    time.sleep(.1)
    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP,0,0)
    print ("Click.")



def mousePos(cord):
    win32api.SetCursorPos((x_pad + cord[0], y_pad + cord[1]))

def get_cords():
    x, y = win32api.GetCursorPos()
    x = x - x_pad
    y = y - y_pad
    print (x, y)

def main():
    screenGrab()

    #grab()


if __name__ == '__main__':
    main()